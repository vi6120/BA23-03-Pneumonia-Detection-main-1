%%%
%
% $Autor: Wings $
% $Datum: 2021-05-14 $
% $Dateiname: 
% $Version: 4620 $
%
% !TeX spellcheck = GB
% !TeX program = pdflatex
% !TeX encoding = utf8
%
%%%


\chapter{Data Analysis with Python: First Step with Pandas - Evaluating Football Data}

\index{Example}

\section{Introduction}
Pandas is the standard library for anyone who wants to process data with Python. This makes it easy to analyze even the first Bundesliga season. Anyone who wants to process or edit data with Python can hardly get around the Pandas library. In a way, it is the gold standard for Python when it comes to structured information.

The size of the original data is irrelevant to Pandas: the library can handle CSV files, Microsoft's Excel format, and large amounts of data in a JSON file. It doesn't matter whether you want to tackle a small or large data project, Pandas usually always simplifies the handling of data of all kinds.

In this article, we explain the basic concepts that Pandas works with: the series and the data frame. We also show how to get free soccer data from the internet and how to analyze the first Bundesliga season 1963/64. Basic Python knowledge is helpful for this, so you should already have installed libraries with pip

The term pandas come from the word panel data, which usually consists of rows and columns. If you want to explain pandas to a non-techie: It's like working with an Excel spreadsheet, only in Python code.

Developer Wes McKinney has been working on Pandas since 2008. At the time, he was still employed by an investment management firm and was looking for a fast and flexible tool to perform quantitative analyses. This eventually led to the open-source library Pandas. There are now 28 maintainers of the software, and McKinney is still  involved


\index{Example!Introduction}


\section{Installation}

The Pandas library is installed using the Pip package manager as follows:

\SHELL{pip install pandas}

Pandas are also part of the Sci-Py stack, an open-source software environment for mathematicians, analysts, and other scientists. Pandas developers prefer to install via the 
\HREF{https://pandas.pydata.org/docs/getting_started/install.html}{Python-Distribution Anaconda},which includes the Sci-Py stack including pandas

\index{Example!Description}

\section{Understand \PYTHON{Series}}

The two main data structures that Pandas provides are the \PYTHON{Series} and the \PYTHON {DataFrame}. The \PYTHON{Series} can be thought of as a simple indexed list, them consists of two arrays. With this code you can create a small \PYTHON{Series} with three elements:

\medskip

\PYTHON{series = pd.Series([1, 2, 3])}

If you output the variable series, the index, which starts at zero, is next to the individual rows:


\PYTHON{0\quad 	1}

\PYTHON{1\quad  2}

\PYTHON{2\quad 	3}

\medskip
The data type of the values is also given in the output, \PYTHON {int64} means 64-bit integers. Using the index, the user can access individual values: \PYTHON {print(series[1])} returns about \PYTHON {2}.

The \PYTHON{Series} may look like a normal Python list, but it works a little differently. For example, you can change the index and then access values from the \PYTHON {series} via the new index:


\index{Example!Installation}



\medskip
\PYTHON {series = pd.Series([1, 2, 3],index=["First digit", "Second digit", "Third digit"])}

\PYTHON {print(series["Second digit"])}

\medskip

This code makes a \PYTHON {2}appear in the output again. In addition, mathematical operations are applied to all \PYTHON {series} values. A paint operation like \PYTHON {series*2} results in the following output:

\medskip


\PYTHON{0\quad 	2}

\PYTHON{1\quad 	4}

\PYTHON{2\quad 	6}

\medskip

This is not possible with a Python list, this operation would only double the list, not the values. The principle is continued if you want to add two \PYTHON {Series objects}, for example:
\medskip

\PYTHON {series1 = pd.Series([1, 2, 3])}

\PYTHON {series2 = pd.Series([4, 5, 6])}  

\PYTHON {print(series1+series2)}

\medskip

The result is a new \PYTHON {Series}, with the added values from the two previous ones:

\medskip

\PYTHON{0\quad 	5}

\PYTHON{1\quad 	7}

\PYTHON{2\quad 	9}

\medskip
If these were two normal list items, the output would look like this instead:

\medskip

\PYTHON{[1, 2, 3, 4, 5, 6]}

\section{Create \PYTHON {DataFrame}}

A \PYTHON {DataFrame} can also be easily created by hand. To do this, you use the \PYTHON {dictionary}
built into Python

\PYTHON {data = {
		"numbers": [1, 2, 3],
		"letters": ["A", "B", "C" ]
}}

The \PYTHON {dictionary} is enclosed in curly brackets and contains two related data separated by colons. Several data pairs are distinguished by commas in the \PYTHON {dictionary}. The first data point is the key, the second is the associated value.

In this example, each key-value pair represents a column in the dataframe. The key consists of a string, here numbers and letters. These will later be the column headers. The corresponding value consists in both cases of a list with three elements, which are then the individual values in the respective column.

The \PYTHON {dictionary} is now passed to Pandas so that it becomes a \PYTHON {DataFrame}:
\medskip
\PYTHON {dataframe = pd.DataFrame(data)}
\medskip

\PYTHON {pd.DataFrame} takes the \PYTHON {dictionary} and stores the \PYTHON {DataFrame} in the variable \PYTHON {dataframe}. In many Pandas examples you will also find the \PYTHON {abbreviation} as the variable name for the \PYTHON {DataFrame}. If you then \PYTHON {print(dataframe)} this variable, you will see the data in a table representation:
\medskip

\PYTHON{\quad\qquad  Numbers \quad  Letters}

\PYTHON{0\qquad 	1        \qquad 	A}

\PYTHON{1\qquad 	2        \qquad 	B}

\PYTHON{2\qquad 	3        \qquad 	C}

\medskip

A first overview of the data can be obtained with \PYTHON {shape}. So \PYTHON {print {(dataframe. shape)}} prints the row \PYTHON(3, 2). So the \PYTHON {DataFrame} consists of 3 rows and 2 columns. \PYTHON {print(len (data frame))} shows you only the number of rows, which is \PYTHON {3}. This is for the sample data is not very surprising, since you know what you have typed. However, as soon as foreign data comes into play, shape0 and \PYTHON {len()} become relevant again.
A summary of the dataframe shows \PYTHON {info()}. For the small example data frame, the input \PYTHON { print (dataframe.info())} gives the following output:

\medskip

\begin{lstlisting}[language=Python]
	<class 'pandas.core.frame.DataFrame'>
	RangeIndex: 3 entries, 0 to 2
	Data columns (total 2 columns):
	#    Column      Non-Zero Count   Dtype
	---  ------      --------------   -----
	0    Nmber        3 non-zero      int64
	1    letter       3 non-zero      object
	dtypes: int64(1), object(1)
	memory usage: 176.0+ bytes
\end{lstlisting}
\medskip

At a glance you can see the index, the number of columns, how many rows the data frame has, and which data types the values in the columns consist of. The first column with the numbers consists of 64-bit integers, this is shown by the hint \PYTHON {int64} under \PYTHON {Dtype} - as already with the \PYTHON {Series}. Finally, \PYTHON {info()} shows how much memory the data frame needs.


\section{Select data}

In order to select a special column from these sample data now, it is sufficient to use the
put the name of the column in square brackets behind the dataframe. \PYTHON {print(dataframe["letters"])}
thus has this issue:

\medskip

\begin{lstlisting}[language=Python]
	0	A
	1	B
	2	C
\end{lstlisting}

\medskip

In addition to the defined rows and values, the \PYTHON {DataFrame} also consists of an index that starts at zero. Via this index you can address a special row, for example, with loc:
\PYTHON {print(dataframe.loc[1])}

If you enter this code, you will only get the values of the second row as output - without index:

\medskip

\begin{lstlisting}[language=Python]
	Number	    2
	Letter  	B
\end{lstlisting}

\medskip


The index can also be customized by passing a list of new index values to the
\PYTHON {DataFrame()} function. This is how the following code becomes

\PYTHON {dataframe = pd.DataFrame(data, index=["First row", "Second row", "Third row"])}
this issue:

\medskip

\begin{lstlisting}[language=Python]
	Number  Letter
	First Row	      1       A
	Second Row        2       B
	Third Row         3       C
\end{lstlisting}

\medskip

The second row can now be \PYTHON {printed} using a \PYTHON {print(dataframe.loc["Second row"])}






\section{Integer}

Besides \PYTHON {loc there} is also \PYTHON{ iloc} - the \PYTHON {i} stands for integer. About this you can call the index interdependently of its self-selected name, but again about its index number. This index also starts at zero. \PYTHON {print(dataframe.iloc[1])} thus gives the same output as \PYTHON { print(dataframe.loc["Second row"])}.

While \PYTHON {loc} and \PYTHON {iloc} select whole rows and columns, you can determine a single value with at. To do this, you pass at the index value and the column name so that the appropriate value is extracted from the \PYTHON {DataFrame}. In the example without a custom index, \PYTHON {print(dataframe.at[0, "letters"])} will output a single \PYTHON {A}. If you use your own index from before, you get the same result with \PYTHON {print(dataframe.at["First row", "Letters"])}.

Similar to \PYTHON {loc} and \PYTHON {iloc}, there is also \PYTHON {iat} in addition to \PYTHON {at}. Those who don't like letters will be happy with this, because the \PYTHON {i} again stands for integer. For the \PYTHON {A} to appear in the output, a \PYTHON {print(dataframe.iat[0, 1])} is sufficient.



\section{Get soccer data}


With the current dataframe, you can only play around and learn about pandas to a limited extent. We need real data. There are plenty of free datasets on the web that you can use for your own projects. On Github you can find all

\HREF{https://github.com/footballcsv/deutschland}{Spielergebnisse der Fußball-Bundesliga im CSV-Format}.

CSV files contain data separated by commas. For humans, the files are rather difficult to read, machines love them. As an example, let's take the first matchday of the very first 

\HREF{https://pandas.pydata.org/pandas-docs/stable/reference/io.html}{Dokumentation}

Pandas can of course also handle other formats, such as Excel files, JSON data or SQL files. An overview of different possibilities shows 
\HREF{https://pandas.pydata.org/pandas-docs/stable/reference/io.html}{Dokumentation}

Now, however, the soccer data must first enter the program. With the function \PYTHON {read\_csv()} Pandas can read CSV files and immediately creates a dataframe from them. If you are in a hurry, just put the link to the data in quotes and pass it to \PYTHON {read\_csv()}:

\medskip

\PYTHON{dataframe = pd.read\_csv("https://raw.githubusercontent.com/footballcsv
	/deutschland/master/1960s/1963-64/de.1.csv")}

\medskip

This is not optimal. The data could eventually disappear from the network and then the whole program would no longer work. After all, nothing on the Internet is for eternity.

It is more elegant to download and save the CSV file. Pandas can then access the saved file. The easiest way to do this is to use the Python library \PYTHON {requests}. You have to install it first, preferably via Pip

\SHELL{pip install requests}

You then get the file onto the disk like this:

\PYTHON {import requests}

\PYTHON{bundesliga\_csv\_url = "https://raw.githubusercontent.com/footballcsv
	/deutschland/master/1960s/1963-64/de.1.csv"}

\PYTHON {download = requests.get(bundesliga\_csv\_url)}
\PYTHON {with open("bundesliga\_erster\_spieltag.csv", "wb") as file:}
\PYTHON {file.write(download.content)}

The variable \PYTHON {bundesliga\_csv\_url} contains the URL to the CSV file, requests.get \PYTHON {(bundesliga\_- csv\_url)} then gets the data via the Get method. The two further lines

save the content, that is \PYTHON {download.content}, as a CSV file. \FILE {bundesliga\_er- ster\_spieltag.csv} is then the name of the CSV file created from it. The file is saved here in the folder where the Python file is located. The script executes the download every time. However, you can also put the few lines in an extra script and run it only once.

Pandas should now work with the downloaded data. Since the file is in the same folder as the script, it is sufficient to enter \PYTHON {dataframe = pd.read\_csv("bundesliga\_- erster\_spieltag.csv")}. If you save the file somewhere else, you have to adjust the path accordingly.







\section{Show info}

Using the methods from before, you can now get some information about the Show \PYTHON {DataFrame}:

\PYTHON {print(len(dataframe))} 
\PYTHON {print(dataframe.shape)} 
\PYTHON {print(dataframe.info())}


\PYTHON {len(dataframe)} again outputs the number of rows, here \PYTHON {240 - 16} teams play \PYTHON {30}
games each, which results in \PYTHON {240} games. The \PYTHON {shape} is \PYTHON {(240, 5)}, so \PYTHON {240} rows and \PYTHON {5} columns. \PYTHON {Info()} finally shows the names of the columns: \PYTHON {Matchday, Date, Team 1, FT} and \PYTHON {Team 2}. Only the data points in \PYTHON { Matchday} are 64-bit integers each, the rest consists of indeterminate types \PYTHON {object}.

So you already know a lot about the data, but what exactly is in it? Is it really soccer information or has someone filled the columns with cooking recipes? Especially when you work with other people's data, you can't avoid taking a look.
A first look is provided by \PYTHON {head()}. With this you quickly get the first 5 entries in the output. \PYTHON {print(dataframe.head())} thus gives in our example

\medskip

{\tiny
	\begin{lstlisting}[language=Python]
		Matchday                Date               Team 1   FT                  Team 2
		0         1  Sat Aug 24 1963        Werder Bremen  3-2       Borussia Dortmund
		1         1  Sat Aug 24 1963    1. FC Saarbr"ucken 0-2             1. FC K"oln
		2         1  Sat  Aug 24 1963   TSV 1860 M"unchen  1-1  Eintracht Braunschweig
		3         1  Sat Aug 24 1963  Eintracht Frankfurt  1-1    1. FC Kaiserslautern
		4         1  Sat Aug 24 1963        FC Schalke 04  2-0           VfB Stuttgart
	\end{lstlisting}
}

\medskip

Lucky, the first rows show soccer data. By the way,  \PYTHON {FT} stands for Full Time, so it gives the result after the full playing time.  \PYTHON {print(dataframe.tail())} shows the last 5 entries:

\medskip

\begin{lstlisting}[language=Python]
	Matchday                 Date             Team 1   FT                Team 2
	235        30  Sat May 9 1964      Karlsruher SC  1-2   Eintracht Frankfurt
	236        30  Sat May 9 1964  TSV 1860 M"unchen  3-2         Werder Bremen
	237        30  Sat May 9 1964 1. FC Saarbr"ucken  1-1         FC Schalke 04
	238        30  Sat May 9 1964  Preu"sen M"unster  4-2            Hertha BSC
	239        30  Sat May 9 1964       MSV Duisburg  3-0  1. FC Kaiserslautern
\end{lstlisting}

\medskip

5 entries is the default value, but you can change that: \PYTHON {dataframe.head(3)} shows only the first 3 entries, for \PYTHON {tail()} it works the same way. If you still want to see data from the middle of the dataframe, you can show it with a simple \PYTHON {slice}, like \PYTHON { print(dataframe[112:116])}.


\section{Goal statistics}

With these few commands, the user now knows what data they are dealing with. Now let's get some interesting statistics from the data. For example, the \PYTHON {value\_counts()} function shows how often a particular value occurs in the data. If you apply it to the \PYTHON {FT} column with the results, you immediately know which final result was most often on the scoreboard. An appended \PYTHON {.head(10)} would, by the way, only output the 10 most frequent results.

The first Bundesliga season must therefore have been quite boring. \PYTHON {print(dataframe[
	"FT"].value\_- counts())} shows that a 1:1 occurred most often, namely 25 times. Directly behind it doesn't get any better, 2:2 was the final result 18 times. A 9:3, 6:1 or 7:0 was rather the exception, these results occurred only once each. By the way, soccer has not exactly become more interesting. In the 2019/20 season, 1:1 was also the most frequent result, occurring 32 times - after all, there were more 2:1 and 1:2 results than in 1963/64, but fewer goal festivals.

All results of a specific matchday can be displayed using the Matchday column. For the 5th matchday the value in the column must be 5. \PYTHON {fuenfter\_spieltag = dataframe["Matchday"] == 5} results in a \PYTHON{ Series} with True and \PYTHON {False values} - if the 5th matchday is the \PYTHON {Series} shows \PYTHON {True}, all other matchdays are\PYTHON {False}. This \PYTHON {Series} is then applied to the \PYTHON {DataFrame}:

\PYTHON {print(dataframe[fift\_game\_day])}

So all rows are output, which belong to the 5th matchday - so all 8 matches. Now we don't want only a certain matchday, but the matches of a bes- tined team. This works basically like before: The team columns are filtered by the club and the resulting true- false series is then applied to the data frame. Here, however, you have to search through two columns, Team 1 and Team 2. The user wants to have all matches listed and not just the home or away matches.
\PYTHON {dataframe["Team 1"] == "Borussia Dortmund" }browses the home matches of Borussia Dortmund, \PYTHON {dataframe["Team 2"] == "Borussia Dortmund"} the away matches. The or operator | connects both commands, which have to be in brackets for this:

\PYTHON {games\_bvb = (dataframe["Team 1"] == "Borussia Dortmund") | (dataframe[
	"Team 2"] == "Borussia Dortmund")}

\PYTHON {spiele\_bvb} is a series that is true whenever Borussia Dortmund plays. If you then apply this series to the entire data frame, you get a list with all the games of the club:
\PYTHON {print(dataframe[games\_bvb])}


\section{Format data}

Data from public sources seldom have the format or the designations that one would like. In the case of Bundesliga data, for example, the English column names are annoying. German names would be more appropriate.
For this Pandas has the handy function \PYTHON {rename()}. You simply put the changes into a \PYTHON {dictionary} and pass it to the function:

\medskip

{\footnotesize
	\begin{lstlisting}[language=Python]
		dataframe = dataframe.rename(columns={"Matchday": "Spieltag",
			"Date": "Date",
			"Team 1": "Homr Team",
			"FT": "Endergebnis",
			"Team 2": "Guest Team"})
	\end{lstlisting}
}

\medskip






Matchday becomes matchday, \PYTHON {team 2 becomes} visiting team and so on. It is somewhat clearer to define the \PYTHON {dictionary} outside the function and then simply call it:

\medskip

{\footnotesize
	\begin{lstlisting}[language=Python]
		replace_column_name = {"Matchday": "Spieltag",
			"Date": "Date",
			"Team 1": "Home Team",
			"FT": "Final Result",
			"Team 2": "Guest Team"
		}
		dataframe = dataframe.rename(columns=replace_column_name)
	\end{lstlisting}
}
\medskip



\section{Date}

So the column names are correctly translated, but the dates are not yet formatted. The first matchday is \PYTHON {Sat Aug 24 1963}, which is better. Pandas provides the function \PYTHON {to\_datetime() for} this:

\PYTHON {dataframe["date"] = pd.to\_datetime(dataframe["date"])}

The function \PYTHON {to\_datetime()} is fed with the date column. The old date column is then replaced with the new, formatted date column. If you output the new column, the first game day is now listed as \PYTHON{1963-08-24}. 

\PYTHON {print(dataframe.info())} shows that the date column is now no longer a type \PYTHON {object}, but a type datetime64[ns]. These are internal 64-bit integers stored in nanoseconds (ns). \PYTHON {datetime64[ns]} can store dates between 1678 and 2262, plus-minus 292 years from January 01, 1970, the start of Unix time.

\PYTHON {1963-08-24} is already quite nice, but if we unambiguate everything, then also the date. The function \PYTHON {dt.strftime()} is responsible for that:

\PYTHON {dataframe["date"] = pd.to\_datetime(dataframe["date"]).dt.strftime("\%A,
	\%d. \%B \%Y")}

The function converts a date element into a string. With special for- matation codes
\PYTHON {Datetime} the content of the string is determined. \PYTHON {\%A }is the written out weekday, \PYTHON {\%d} the day, \PYTHON {\%B} the written out month and \PYTHON {\%Y} the year with four digits.

In order for the formatting codes to display German weekdays and months, the user may need to include the \PYTHON {locale} library beforehand. It is integrated in Python by default, so it does not have to be installed via pip and provides country-specific data formats:

\PYTHON {import locale locale.setlocale(locale.LC\_ALL, "en\_DE")}

\PYTHON {LC\_ALL} means that all country-specific formats are addressed. \PYTHON{de\_DE} is a Language Code Identifier and means quasi: German in Germany. \PYTHON {de\_AT} would be German in Austria for example.
If you now output the date, this line, among others, is in the output:

\PYTHON {Saturday, August 24, 1963}

But this makes the date column a type \PYTHON{object} again and no longer a type \PYTHON{datetime64}
- all string elements are a type \PYTHON{object} for Pandas. However, the focus here is on human readability, not machine readability. To change the data in the column back to a Type \PYTHON{datetime64}, apply the function \PYTHON{to\_datetime()} again, but give it the previously used formatting codes of \PYTHON{dt.strftime()} as parameters:

\PYTHON {dataframe["date"] = pd.to\_datetime(dataframe["date"], format="\%A,\%d.
	\%B \%Y")}

By means of the parameter  \PYTHON {format} the function recognizes the content of the string and can format as the correct date.

















